
name: Upstream Issue Checker

on:
  workflow_dispatch:
  schedule:
    - cron: '0 0 * * 0'  # Runs at 00:00 every Sunday.
  push:
    branches:
      - main

permissions:
  issues: write
  
jobs:
  check_upstream_issues:
    runs-on: ubuntu-latest

    steps:
      - name: Check and Comment on Upstream Issues
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const BUGZILLA_HOSTNAME = 'bugzilla.mozilla.org';
            const BUGZILLA_REGEX = new RegExp(`https://${BUGZILLA_HOSTNAME}/show_bug\\.cgi\\?id=(\\d+)`);
            const GH_ACTION_DATA_REGEX = /<!---GH-ACTION-DATA-(.*)-GH-ACTION-DATA--->/;

            console.log('Starting to process GitHub issues labeled "upstream"...');

            // Paginate through all open issues with label "upstream"
            for await (const { data: issues } of github.paginate.iterator(github.rest.issues.listForRepo, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'upstream'
            })) {
              for (const issue of issues) {
                console.log(`Processing issue https://github.com/${context.repo.owner}/${context.repo.repo}/issues/${issue.number}`);

                // Paginate through comments for the specific issue
                for await (const { data: comments } of github.paginate.iterator(github.rest.issues.listComments, {
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: issue.number
                })) {
                  const previousComment = comments.find(comment => comment.user.login === 'github-actions[bot]');
                  const previousDataMatch = previousComment?.body.match(GH_ACTION_DATA_REGEX);
                  const previousData = previousDataMatch?.[1] ? JSON.parse(previousDataMatch[1]) : null;

                  for (const comment of comments) {
                    if (comment.author_association != "OWNER" && comment.author_association != "MEMBER") {
                      continue;
                    }
                    const match = comment.body.match(BUGZILLA_REGEX);
                    if (!match) {
                      continue;
                    }

                    const bugId = match[1];
                    console.log(`\tFetching Bugzilla data for ${match[0]}`);

                    const response = await fetch(`https://${BUGZILLA_HOSTNAME}/rest/bug/${bugId}`);
                    const data = await response.json();
                    const bug = data?.bugs?.[0];

                    if (!bug) {
                      console.log(`\tNo data found for Bugzilla bug ID ${bugId}. Skipping...`);
                      continue;
                    }

                    const { resolution, status, target_milestone: targetMilestone, last_change_time: lastChangedDate } = bug;

                    if (previousData) {
                      if (previousData.lastChangedDate === lastChangedDate || (previousData.status === status && previousData.resolution == resolution)) {
                        console.log(`\tNo changes detected for Bugzilla bug ID ${bugId}. Skipping...`);
                        continue;
                      }
                    }

                    if (status === 'RESOLVED') {
                      const commentContent =
                        `Upstream issue [bug ${bugId}](https://${BUGZILLA_HOSTNAME}/show_bug.cgi?id=${bugId}) has changed to ${status} ${resolution} and will be ready for Thunderbird ${targetMilestone}.\n` +
                        `<!---GH-ACTION-DATA-${JSON.stringify({ resolution, status, targetMilestone, lastChangedDate })}-GH-ACTION-DATA--->`;

                      console.log(`\tCreating comment on issue #${issue.number} regarding bug ${bugId}'s status...`);
                      await github.rest.issues.createComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: issue.number,
                        body: commentContent
                      });
                    } else {
                      console.log(`\tCurrent status is ${status} ${resolution}`);
                    }
                  }
                }
              }
            }

            console.log('Finished processing GitHub issues.');
